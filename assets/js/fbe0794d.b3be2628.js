"use strict";(self.webpackChunkdade_documentation=self.webpackChunkdade_documentation||[]).push([[186],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return c}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),o=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=o(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),m=o(n),c=l,f=m["".concat(s,".").concat(c)]||m[c]||d[c]||r;return n?a.createElement(f,i(i({ref:t},p),{},{components:n})):a.createElement(f,i({ref:t},p))}));function c(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=m;var u={};for(var s in t)hasOwnProperty.call(t,s)&&(u[s]=t[s]);u.originalType=e,u.mdxType="string"==typeof e?e:l,i[1]=u;for(var o=2;o<r;o++)i[o]=n[o];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2248:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return u},metadata:function(){return o},toc:function(){return d}});var a=n(7462),l=n(3366),r=(n(7294),n(3905)),i=["components"],u={title:"field"},s="Fields",o={unversionedId:"usage/fields",id:"usage/fields",title:"field",description:"We describe a field in dade that supports types and usage conditions.",source:"@site/docs/usage/fields.md",sourceDirName:"usage",slug:"/usage/fields",permalink:"/dade/usage/fields",tags:[],version:"current",frontMatter:{title:"field"},sidebar:"sidebar",previous:{title:"models",permalink:"/dade/usage/models"},next:{title:"schema",permalink:"/dade/usage/schema"}},p={},d=[{value:"Support types",id:"support-types",level:2},{value:"numeric",id:"numeric",level:3},{value:"Usage",id:"usage",level:4},{value:"String",id:"string",level:3},{value:"Array",id:"array",level:3},{value:"Boolean",id:"boolean",level:3},{value:"Null",id:"null",level:3},{value:"Usage",id:"usage-1",level:4},{value:"Optional",id:"optional",level:3},{value:"Usage",id:"usage-2",level:4},{value:"Term of fields",id:"term-of-fields",level:2},{value:"Alias",id:"alias",level:3},{value:"Default",id:"default",level:3},{value:"Validate",id:"validate",level:3}],m={toc:d};function c(e){var t=e.components,n=(0,l.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"fields"},"Fields"),(0,r.kt)("p",null,"We describe a field in dade that supports types and usage conditions."),(0,r.kt)("h2",{id:"support-types"},"Support types"),(0,r.kt)("h3",{id:"numeric"},"numeric"),(0,r.kt)("p",null,"This numeric in dade is u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize, f32, or f64 in Rust."),(0,r.kt)("p",null,"We can validate greater than, less than, or equal for a numeric type.\nFor detail,"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The term ",(0,r.kt)("inlineCode",{parentName:"li"},"gt")," means to validate greater than the given value."),(0,r.kt)("li",{parentName:"ul"},"The term ",(0,r.kt)("inlineCode",{parentName:"li"},"ge")," means to validate equal to or greater than the given value."),(0,r.kt)("li",{parentName:"ul"},"The term ",(0,r.kt)("inlineCode",{parentName:"li"},"lt")," means to validate less than the given value."),(0,r.kt)("li",{parentName:"ul"},"The term ",(0,r.kt)("inlineCode",{parentName:"li"},"le")," means to validate equal to or less than the given value.")),(0,r.kt)("h4",{id:"usage"},"Usage"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[model]\nstruct Id {\n    #[field(ge = 1, lt = 100)]\n    id: u64\n}\n")),(0,r.kt)("h3",{id:"string"},"String"),(0,r.kt)("p",null,"This string in dade is String in Rust.\nIn this version, dade does not support char and bytes."),(0,r.kt)("p",null,"Supported terms are below. "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"min_length"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If set, a string must have a length equal to or greater than the given value."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max_length"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If set, a string must have a length equal to or less than the given value.")))),(0,r.kt)("h3",{id:"array"},"Array"),(0,r.kt)("p",null,"This array in dade is Vec in Rust."),(0,r.kt)("p",null,"Supported terms are below. "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"min_items"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If set, an array must have a length equal to or greater than the given value."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max_items"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If set, an array must have a length equal to or less than the given value.")))),(0,r.kt)("h3",{id:"boolean"},"Boolean"),(0,r.kt)("p",null,"This boolean in dade is Boolean in Rust."),(0,r.kt)("h3",{id:"null"},"Null"),(0,r.kt)("p",null,"This null in dade is unit",(0,r.kt)("inlineCode",{parentName:"p"},"()")," in Rust.\nThis value is only null in JSON."),(0,r.kt)("h4",{id:"usage-1"},"Usage"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[model]\nstruct Empty {\n    empty: ()\n}\n")),(0,r.kt)("h3",{id:"optional"},"Optional"),(0,r.kt)("p",null,"In case of value exists or does not in JSON, you can use Option in Rust."),(0,r.kt)("h4",{id:"usage-2"},"Usage"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[model]\nstruct Item {\n    value: Option<u32>\n}\n")),(0,r.kt)("h2",{id:"term-of-fields"},"Term of fields"),(0,r.kt)("h3",{id:"alias"},"Alias"),(0,r.kt)("p",null,"The usage of the term Alias is two methods.\nIf a key in JSON maps another named field in a model, you can use the term Alias."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[model]\nstruct  Item {\n    #[field(alias = "val")]\n    value: u64,\n}\n')),(0,r.kt)("p",null,"Then, the following passed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let item = Item::parse("{\\"val\\": 1}");\n')),(0,r.kt)("p",null,"On the other hand, use in an enum.\nFor example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[model]\nenum Pattern {\n    #[field(alias = "p1")]\n    Pattern1,\n    #[field(alias = "p2")]\n    Pattern2,\n}\n')),(0,r.kt)("p",null,"In this case, "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If a JSON value is ",(0,r.kt)("inlineCode",{parentName:"li"},'"p1"'),", the parse result will be ",(0,r.kt)("inlineCode",{parentName:"li"},"Pattern::Pattern1"),"."),(0,r.kt)("li",{parentName:"ul"},"If a JSON value is ",(0,r.kt)("inlineCode",{parentName:"li"},'"p2"'),", the parse result will be ",(0,r.kt)("inlineCode",{parentName:"li"},"Pattern::Pattern2"),"."),(0,r.kt)("li",{parentName:"ul"},"If a JSON value is another string, the parse be failed.")),(0,r.kt)("h3",{id:"default"},"Default"),(0,r.kt)("p",null,"If a key does not exist in JSON, dade set a given value corresponding to it."),(0,r.kt)("p",null,"For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[model]\nstruct  Item {\n    #[field(default = 1)]\n    value: u64,\n}\n")),(0,r.kt)("p",null,"Then, the following passed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let item = Item::parse("{}");\n// item = {value: 1}\n')),(0,r.kt)("h3",{id:"validate"},"Validate"),(0,r.kt)("p",null,"If you want to validate value to a custom validator, you can use the term validate."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use dade::{model, Model, Result, Error};\nfn custom_validate(value: i8) -> Result<i8> {\n    if value > 0 {\n        Ok(value)\n    } else {\n        Err(Error::validate_err("only positive"))\n    }\n}\n\n#[model]\nstruct Item {\n    #[field(validate = custom_validate)]\n    value: i8\n}\n')),(0,r.kt)("p",null,"In this, the following is failed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let instance = Item::parse("{\\"value\\": -1}")?;\n')))}c.isMDXComponent=!0}}]);